
1> Determine if a browser implements DnD, always use feature detection rather than sniffing the browser's User-Agent. 
Better libraries for feature detection is Modernizr. Modernizr sets a boolean property for each feature it tests. Thus, checking for DnD is a one-liner:
if (Modernizr.draganddrop) {
  // Browser supports HTML5 DnD.
} else {
  // Fallback to a library solution.
}

2> Creating draggable content
Set the draggable=true; Just about anything can be drag-enabled, including images, links, files, or other DOM nodes.
Note: in most browsers, text selections, img elements, and anchor elements with an href attribute are draggable by default. 
Most browsers support dragging an image by default, which can be dropped in the address bar, a <input type="file" /> element, or even the desktop. 

3> CSS Sample for visual indicator of movable elements:  

<style>
/* Prevent the text contents of draggable elements from being selectable. */
[draggable] {
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  user-select: none;
  /* Required to make elements draggable in old WebKit */
  -khtml-user-drag: element;
  -webkit-user-drag: element;
}
.column {
  height: 150px;
  width: 150px;
  float: left;
  border: 2px solid #666666;
  background-color: #ccc;
  margin-right: 5px;
  -webkit-border-radius: 10px;
  -ms-border-radius: 10px;
  -moz-border-radius: 10px;
  border-radius: 10px;
  -webkit-box-shadow: inset 0 0 3px #000;
  -ms-box-shadow: inset 0 0 3px #000;
  box-shadow: inset 0 0 3px #000;
  text-align: center;
  cursor: move;
}
.column header {
  color: #fff;
  text-shadow: #000 0 1px;
  box-shadow: 5px;
  padding: 5px;
  background: -moz-linear-gradient(left center, rgb(0,0,0), rgb(79,79,79), rgb(21,21,21));
  background: -webkit-gradient(linear, left top, right top,
                               color-stop(0, rgb(0,0,0)),
                               color-stop(0.50, rgb(79,79,79)),
                               color-stop(1, rgb(21,21,21)));
  background: -webkit-linear-gradient(left center, rgb(0,0,0), rgb(79,79,79), rgb(21,21,21));
  background: -ms-linear-gradient(left center, rgb(0,0,0), rgb(79,79,79), rgb(21,21,21));
  border-bottom: 1px solid #ddd;
  -webkit-border-top-left-radius: 10px;
  -moz-border-radius-topleft: 10px;
  -ms-border-radius-topleft: 10px;
  border-top-left-radius: 10px;
  -webkit-border-top-right-radius: 10px;
  -ms-border-top-right-radius: 10px;
  -moz-border-radius-topright: 10px;
  border-top-right-radius: 10px;
}
</style>

4> Listening for Dragging Events
dragstart
drag
dragenter
dragleave
dragover
drop
dragend

To handle the DnD flow, we need the notion of 
- a source element (where the drag originates), can be an image, list, link, file object, block of HTML
- the data payload (what we're trying to drop), and 
- a target (an area to catch the drop). The drop zone (or set of drop zones) that accepts the data the user is trying to drop. Keep in mind that not all elements can be targets (e.g. images).

4.1>. Starting a Drag
function handleDragStart(e) {
  this.style.opacity = '0.4';  // this / e.target is the source node.
}
var cols = document.querySelectorAll('#columns .column');
[].forEach.call(cols, function(col) {
  col.addEventListener('dragstart', handleDragStart, false);
});

4.2. dragenter, dragover, and dragleave
dragenter, dragover, and dragleave event handlers can be used to provide additional visual cues during the drag process. 
For example, when a column is hovered over during a drag, its border could become dashed. This will let users know the columns are also drop targets.

<style>
.column.over {
  border: 2px dashed #000;
}
</style>

function handleDragStart(e) {
  this.style.opacity = '0.4';  // this / e.target is the source node.
}

function handleDragOver(e) {
  if (e.preventDefault) {
    e.preventDefault(); // Necessary. Allows us to drop.
  }

  e.dataTransfer.dropEffect = 'move';  // See the section on the DataTransfer object.

  return false;
}

function handleDragEnter(e) {
  // this / e.target is the current hover target.
  this.classList.add('over');
}

function handleDragLeave(e) {
  this.classList.remove('over');  // this / e.target is previous target element.
}

var cols = document.querySelectorAll('#columns .column');
[].forEach.call(cols, function(col) {
  col.addEventListener('dragstart', handleDragStart, false);
  col.addEventListener('dragenter', handleDragEnter, false);
  col.addEventListener('dragover', handleDragOver, false);
  col.addEventListener('dragleave', handleDragLeave, false);
});

There are a couple of points worth covering in this code:
- The this/e.target changes for each type of event, depending on where we are in the DnD event model.
- In the case of dragging something like a link, we need to prevent the browser's default behavior, which is to navigate to that link. 
To do this, call e.preventDefault() in the dragover event. 
- Another good practice is to return false in that same handler. Browsers are somewhat inconsistent about needing these, but they don't hurt to add.
- dragenter/drarleave is used to add/remove 'over' class instead of the dragover, which will happen many times. 

4.3 > Completing a Drag
- Add an event listener for the drop and dragend events. 
- Need to prevent the browser's default behavior for drops, which is typically some sort of annoying redirect. 
- Can prevent the event from bubbling up the DOM by calling e.stopPropagation().
- Immediate improvement is to use dragend to remove the 'over' class. 

function handleDrop(e) {
  // this / e.target is current target element.

  if (e.stopPropagation) {
    e.stopPropagation(); // stops the browser from redirecting.
  }

  // See the section on the DataTransfer object.

  return false;
}

function handleDragEnd(e) {
  // this/e.target is the source node.

  [].forEach.call(cols, function (col) {
    col.classList.remove('over');
  });
}

var cols = document.querySelectorAll('#columns .column');
[].forEach.call(cols, function(col) {
  col.addEventListener('dragstart', handleDragStart, false);
  col.addEventListener('dragenter', handleDragEnter, false)
  col.addEventListener('dragover', handleDragOver, false);
  col.addEventListener('dragleave', handleDragLeave, false);
  col.addEventListener('drop', handleDrop, false);
  col.addEventListener('dragend', handleDragEnd, false);
});

5> The DataTransfer object
dataTransfer is set in the dragstart event and read/handled in the drop event. 
Calling e.dataTransfer.setData(format, data) will set the object's content to the mimetype and data payload passed as arguments.

var dragSrcEl = null;

function handleDragStart(e) {
  // Target (this) element is the source node.
  this.style.opacity = '0.4';

  dragSrcEl = this;

  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/html', this.innerHTML);
}

Conveniently, dataTransfer also has a getData(format) for fetching the drag data by mimetype. 

function handleDrop(e) {
  // this/e.target is current target element.

  if (e.stopPropagation) {
    e.stopPropagation(); // Stops some browsers from redirecting.
  }

  // Don't do anything if dropping the same column we're dragging.
  if (dragSrcEl != this) { //Global variable to denote teh soruce element starting the drag/drop.
    // Set the source column's HTML to the HTML of the column we dropped on.
    dragSrcEl.innerHTML = this.innerHTML;
    this.innerHTML = e.dataTransfer.getData('text/html');
  }
  return false;
}

6> Dragging properties

The dataTransfer object exposes properties to provide visual feedback to the user during the drag process. 
These properties can also be used to control how each drop target responds to a particular data type.

6.1> dataTransfer.effectAllowed
Restricts what 'type of drag' the user can perform on the element. 
It is used in the drag-and-drop processing model to initialize the dropEffect during the dragenter and dragover events. 
The property can be set to the following values: none, copy, copyLink, copyMove, link, linkMove, move, all, and uninitialized.
6.2> dataTransfer.dropEffect
Controls the feedback that the user is given during the dragenter and dragover events. 
When the user hovers over a target element, the browser's cursor will indicate what type of operation is going to take place (e.g. a copy, a move, etc.). 
The effect can take on one of the following values: none, copy, link, move.

6.3> e.dataTransfer.setDragImage(imgElement, x, y)
Instead of using the browser's default 'ghost image' feedback, you can optionally set a drag icon
var dragIcon = document.createElement('img');
dragIcon.src = 'logo.png';
dragIcon.width = 100;
e.dataTransfer.setDragImage(dragIcon, -10, -10);

7> Dragging Files
Possible to drag files from the desktop to your web app in the browser window. 
As an extension to this idea, Google Chrome supports the ability to drag file objects out from the browser to the desktop.

7.1> Drag-in: dragging from the desktop to the browser
Dragging a file from the desktop is achieved by using the DnD events as other types of content. 
The main difference is in your drop handler. Instead of using dataTransfer.getData() to access the files, their data will be contained in the dataTransfer.files property:

function handleDrop(e) {
  e.stopPropagation(); // Stops some browsers from redirecting.
  e.preventDefault();

  var files = e.dataTransfer.files;
  for (var i = 0, f; f = files[i]; i++) {
    // Read the File objects in this FileList.
  }
}
For a complete guide to dragging files from desktop to the browser, see Using drag and drop for selecting in Reading local files in JavaScript.

7.2> Drag-out: dragging from the browser to the desktop
For a complete guide to dragging files from the browser to the desktop, see Drag out files like Gmail from the CSS Ninja.

